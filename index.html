<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>Untitled</title>
    

  </head>
    
  <body>
  <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hybrid Supernova Engine - Manual Tracklist</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; cursor: crosshair; }
        canvas { display: block; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        
        /* --- MAIN UI (Top Left) --- */
        #ui {
            position: absolute; top: 15px; left: 15px;
            color: #fff; font-family: 'Segoe UI', Tahoma, sans-serif;
            pointer-events: auto; text-transform: uppercase; letter-spacing: 1px; font-size: 10px;
            background: rgba(15, 15, 15, 0.9); padding: 18px; border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 240px; box-shadow: 0 8px 32px rgba(0,0,0,0.8);
            user-select: none; z-index: 20;
        }

        /* --- MUSIC UI (Bottom Left) --- */
        #music-ui {
            position: absolute; bottom: 15px; left: 15px;
            color: #fff; font-family: 'Segoe UI', Tahoma, sans-serif;
            pointer-events: auto; text-transform: uppercase; letter-spacing: 1px; font-size: 10px;
            background: rgba(15, 15, 15, 0.9); padding: 18px; border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 240px; box-shadow: 0 8px 32px rgba(0,0,0,0.8);
            user-select: none; z-index: 20;
        }

        .status { margin-bottom: 12px; font-weight: 800; font-size: 11px; }
        .ready { color: #00ffcc; }
        .charging { color: #ff3366; }
        .slider-group { margin-bottom: 12px; }
        label { display: block; margin-bottom: 4px; color: #888; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #00ffcc; }
        .val { float: right; color: #00ffcc; font-family: monospace; text-decoration: underline; cursor: pointer; }
        
        #fpsCounter {
            position: absolute; top: 15px; right: 15px;
            color: #0f0; font-family: monospace; font-size: 14px;
            background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; z-index: 20;
        }
        
        .btn-container { display: flex; gap: 5px; margin-top: 10px; }
        button {
            flex: 1; background: #222; color: #fff; border: 1px solid #444;
            padding: 8px; border-radius: 4px; font-size: 9px; cursor: pointer;
            text-transform: uppercase; transition: 0.2s;
        }
        button.active { background: #00ffcc; color: #000; border-color: #00ffcc; }
        button:hover { background: #333; }
        button.active:hover { background: #00e6b8; }
        
        .color-pickers { display: flex; gap: 5px; margin-top: 5px; }
        input[type=color] { width: 100%; height: 20px; border: none; background: none; cursor: pointer; }

        /* Music Specific Styles */
        .music-header { color: #888; margin-bottom: 5px; font-weight: 800; display: flex; justify-content: space-between; }
        #song-name { 
            color: #00ffcc; margin-bottom: 8px; font-weight: bold; font-size: 11px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 
        }
        #yt-player { display: none; } /* Hide the actual video */
    </style>
</head>
<body>
    <div id="fpsCounter">FPS: 0</div>
    
    <div id="ui">
        <div id="statusText" class="status ready">SYSTEM READY</div>
        
        <div class="slider-group">
            <label>Particles <span id="pCount" class="val">50,000</span></label>
            <input type="range" id="pSlider" min="1000" max="10000000" step="1000" value="50000">
        </div>

        <div class="slider-group">
            <label>Explosion Force <span id="ePower" class="val">1200</span></label>
            <input type="range" id="eSlider" min="50" max="5000" step="50" value="1200">
        </div>

        <div class="slider-group">
            <label>Drift (Ice Factor) <span id="fVal" class="val">3.0</span></label>
            <input type="range" id="fSlider" min="1" max="5" step="0.1" value="3.0">
        </div>

        <div class="slider-group">
            <label>Spiral Speed <span id="sVal" class="val">1.6</span></label>
            <input type="range" id="sSlider" min="0.1" max="5" step="0.1" value="1.6">
        </div>

        <div class="slider-group">
            <label>Colors</label>
            <div class="color-pickers">
                <input type="color" id="c1" value="#ffffff">
                <input type="color" id="c2" value="#888888">
                <input type="color" id="c3" value="#00f2ff">
            </div>
        </div>

        <div class="btn-container">
            <button id="btnWebGL" class="active">WebGL (High Capacity)</button>
            <button id="btnCanvas">Canvas 2D (Legacy)</button>
        </div>
        <button id="bhBtn" style="margin-top: 5px; width: 100%;">Black Hole: OFF</button>
    </div>

    <div id="music-ui">
        <div class="music-header">ZONE TIME <span id="zone-time">00:00:00</span></div>
        <div id="song-name">Initializing...</div>
        
        <input type="range" id="music-progress" value="0" min="0" max="100" style="margin-bottom: 8px;">
        
        <div class="btn-container">
            <button id="play-pause-btn">WAIT...</button>
            <button id="next-track-btn">NEXT TRACK</button>
        </div>
    </div>

    <div id="yt-player"></div>

    <canvas id="glCanvas"></canvas>
    <canvas id="c2dCanvas" style="display:none;"></canvas>

<script src="https://www.youtube.com/iframe_api"></script>

<script>
    // --- YOUTUBE API LOGIC (INDIVIDUAL TRACKS) ---
    let player;
    // IDs extracted from your links
    const trackList = [
        'jCEZOqPqhLs', // Resonance
        'jd6dPtN9E9g', // Odyssey
        'L_UBFnwaOgY', // Decay
        'hraj31Bc5Gc', // Before the Night
        '76r8I6OPQ8I', // We're Finally Landing
        'edjvrsu3zbY', // Head First
        'KA8pKSDQv9A'  // Flood
    ];
    let currentTrackIndex = 0;

    function onYouTubeIframeAPIReady() {
        player = new YT.Player('yt-player', {
            height: '0',
            width: '0',
            videoId: trackList[currentTrackIndex],
            playerVars: {
                'playsinline': 1,
                'controls': 0,
                'disablekb': 1
            },
            events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange
            }
        });
    }

    function onPlayerReady(event) {
        document.getElementById('play-pause-btn').innerText = "PLAY";
        document.getElementById('song-name').innerText = "Ready to Start";
        
        // Update Loop for Time and Progress
        setInterval(() => {
            // Update Clock
            const now = new Date();
            document.getElementById('zone-time').innerText = now.toLocaleTimeString();

            // Update Progress Bar if playing
            if(player && player.getPlayerState() === YT.PlayerState.PLAYING) {
                const cur = player.getCurrentTime();
                const dur = player.getDuration();
                if(dur > 0) {
                    const pct = (cur / dur) * 100;
                    document.getElementById('music-progress').value = pct;
                }
                // Try to get title from API
                const data = player.getVideoData();
                if(data && data.title) {
                    document.getElementById('song-name').innerText = data.title;
                }
            }
        }, 1000);
    }

    function onPlayerStateChange(event) {
        const btn = document.getElementById('play-pause-btn');
        
        if (event.data === YT.PlayerState.PLAYING) {
            btn.innerText = "PAUSE";
            const data = player.getVideoData();
            if(data && data.title) document.getElementById('song-name').innerText = data.title;
        } 
        else if (event.data === YT.PlayerState.ENDED) {
            // Auto-play next track when one finishes
            playNextTrack();
        } 
        else {
            btn.innerText = "PLAY";
        }
    }

    function playNextTrack() {
        currentTrackIndex++;
        if (currentTrackIndex >= trackList.length) {
            currentTrackIndex = 0; // Loop back to start
        }
        if(player) {
            player.loadVideoById(trackList[currentTrackIndex]);
        }
    }

    // Music Controls
    document.getElementById('play-pause-btn').onclick = function() {
        if(!player) return;
        const state = player.getPlayerState();
        if(state === YT.PlayerState.PLAYING) {
            player.pauseVideo();
        } else {
            player.playVideo();
        }
    };

    document.getElementById('next-track-btn').onclick = function() {
        playNextTrack();
    };

    document.getElementById('music-progress').oninput = function(e) {
        if(player) {
            const dur = player.getDuration();
            const seekTo = (e.target.value / 100) * dur;
            player.seekTo(seekTo, true);
        }
    };


    // --- SUPERNOVA ENGINE LOGIC ---
    const glCanvas = document.getElementById('glCanvas');
    const c2dCanvas = document.getElementById('c2dCanvas');
    const gl = glCanvas.getContext('webgl', { alpha: false, antialias: false });
    const ctx = c2dCanvas.getContext('2d', { alpha: false });

    // State
    let mode = 'webgl'; 
    let count = 50000;
    let explosionStrength = 1200;
    let driftFactor = 3.0;
    let swirlForce = 1.6;
    let blackHoleActive = false;
    let lastExplosionTime = 0;
    const cooldownMs = 1200;

    const mouse = { x: 0, y: 0, isDown: false, wasDown: false, glX: 0, glY: 0 };

    function resize() {
        glCanvas.width = c2dCanvas.width = window.innerWidth;
        glCanvas.height = c2dCanvas.height = window.innerHeight;
        if (gl) gl.viewport(0, 0, glCanvas.width, glCanvas.height);
    }

    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', e => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
        mouse.glX = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.glY = (e.clientY / window.innerHeight) * -2 + 1;
    });
    window.addEventListener('mousedown', e => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
        if (Date.now() - lastExplosionTime > cooldownMs) mouse.isDown = true;
    });
    window.addEventListener('mouseup', () => mouse.isDown = false);

    // --- WebGL Shaders & Setup ---
    const vs = `attribute vec2 a_pos; attribute vec3 a_col; attribute float a_size; varying vec3 v_col; void main() { gl_Position = vec4(a_pos, 0.0, 1.0); gl_PointSize = a_size; v_col = a_col; }`;
    const fs = `precision mediump float; varying vec3 v_col; void main() { gl_FragColor = vec4(v_col, 1.0); }`;
    
    function createShader(gl, type, src) {
        const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); return s;
    }
    const prg = gl.createProgram();
    gl.attachShader(prg, createShader(gl, gl.VERTEX_SHADER, vs));
    gl.attachShader(prg, createShader(gl, gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(prg); gl.useProgram(prg);

    const posLoc = gl.getAttribLocation(prg, "a_pos");
    const colLoc = gl.getAttribLocation(prg, "a_col");
    const sizeLoc = gl.getAttribLocation(prg, "a_size");

    const MAX_P = 10000000;
    const posArr = new Float32Array(MAX_P * 2);
    const velArr = new Float32Array(MAX_P * 2);
    const colArr = new Float32Array(MAX_P * 3);
    const sizeArr = new Float32Array(MAX_P);
    const speedArr = new Float32Array(MAX_P);

    function updateColors() {
        const c = [
            hexToRgb(document.getElementById('c1').value),
            hexToRgb(document.getElementById('c2').value),
            hexToRgb(document.getElementById('c3').value)
        ];
        for (let i = 0; i < MAX_P; i++) {
            let r = Math.random();
            let sel = r < 0.8 ? c[0] : (r < 0.9 ? c[1] : c[2]);
            colArr[i*3] = sel[0]; colArr[i*3+1] = sel[1]; colArr[i*3+2] = sel[2];
        }
    }

    function hexToRgb(hex) {
        return [parseInt(hex.slice(1,3),16)/255, parseInt(hex.slice(3,5),16)/255, parseInt(hex.slice(5,7),16)/255];
    }

    function initData() {
        for (let i = 0; i < MAX_P; i++) {
            posArr[i*2] = Math.random()*2-1; posArr[i*2+1] = Math.random()*2-1;
            sizeArr[i] = (Math.random() * 1.4 + 0.5) * 1.3375;
            speedArr[i] = 0.006 + Math.random() * 0.01;
        }
        updateColors();
    }
    initData();

    const pBuf = gl.createBuffer();
    const cBuf = gl.createBuffer();
    const sBuf = gl.createBuffer();

    // --- UI Logic ---
    const bind = (id, valId, fn) => {
        const s = document.getElementById(id), v = document.getElementById(valId);
        s.oninput = () => { v.innerText = Number(s.value).toLocaleString(); fn(s.value); };
        v.onclick = () => { let res = prompt("Value:", s.value); if(res){ s.value = res; v.innerText = Number(res).toLocaleString(); fn(res); }};
    };

    bind('pSlider', 'pCount', v => count = parseInt(v));
    bind('eSlider', 'ePower', v => explosionStrength = parseFloat(v));
    bind('fSlider', 'fVal', v => driftFactor = parseFloat(v));
    bind('sSlider', 'sVal', v => swirlForce = parseFloat(v));

    document.getElementById('c1').oninput = updateColors;
    document.getElementById('c2').oninput = updateColors;
    document.getElementById('c3').oninput = updateColors;

    document.getElementById('btnWebGL').onclick = function() {
        mode = 'webgl'; glCanvas.style.display = 'block'; c2dCanvas.style.display = 'none';
        this.classList.add('active'); document.getElementById('btnCanvas').classList.remove('active');
    };
    document.getElementById('btnCanvas').onclick = function() {
        mode = 'canvas'; glCanvas.style.display = 'none'; c2dCanvas.style.display = 'block';
        this.classList.add('active'); document.getElementById('btnWebGL').classList.remove('active');
    };
    document.getElementById('bhBtn').onclick = function() {
        blackHoleActive = !blackHoleActive;
        this.innerText = `Black Hole: ${blackHoleActive ? 'ON' : 'OFF'}`;
        this.classList.toggle('active');
    };

    // --- Animation Loop ---
    let lastTime = performance.now();
    let frames = 0, fpsTime = 0;

    function animate(now) {
        const dt = (now - lastTime) / 16.667;
        lastTime = now;
        frames++;
        if (now > fpsTime + 1000) { 
            document.getElementById('fpsCounter').innerText = `FPS: ${frames}`; 
            frames = 0; fpsTime = now; 
        }

        const statusLabel = document.getElementById('statusText');
        const isCooling = (Date.now() - lastExplosionTime) < cooldownMs;
        if(isCooling) {
            statusLabel.innerText = "COOLDOWN..."; statusLabel.className = "status charging";
            mouse.isDown = false;
        } else {
            statusLabel.innerText = mouse.isDown ? "COMPRESSING..." : "SYSTEM READY";
            statusLabel.className = "status ready";
        }

        const justReleased = mouse.wasDown && !mouse.isDown && !isCooling;
        if(justReleased) lastExplosionTime = Date.now();

        if (mode === 'webgl') {
            runWebGL(dt, justReleased);
        } else {
            runCanvas(dt, justReleased);
        }

        mouse.wasDown = mouse.isDown;
        requestAnimationFrame(animate);
    }

    function runWebGL(dt, released) {
        const friction = Math.pow(0.82 + (driftFactor / 5) * 0.178, dt);
        const bhPull = 0.003 * dt;

        for (let i = 0; i < count; i++) {
            const i2 = i * 2;
            let dx = mouse.glX - posArr[i2];
            let dy = mouse.glY - posArr[i2+1];
            let dist = Math.sqrt(dx*dx + dy*dy) || 0.001;

            if (mouse.isDown) {
                const sx = -dy / dist;
                const sy = dx / dist;
                velArr[i2] += (dx * speedArr[i] * dt) + (sx * swirlForce * 0.02 * dt);
                velArr[i2+1] += (dy * speedArr[i] * dt) + (sy * swirlForce * 0.02 * dt);
                velArr[i2] *= Math.pow(0.88, dt);
                velArr[i2+1] *= Math.pow(0.88, dt);
            } else if (released) {
                const f = (1.0 / dist) * (explosionStrength / 40000);
                velArr[i2] = (-dx / dist) * f * (Math.random() * 2 + 0.5);
                velArr[i2+1] = (-dy / dist) * f * (Math.random() * 2 + 0.5);
            } else {
                velArr[i2] *= friction; velArr[i2+1] *= friction;
                if(blackHoleActive) {
                    velArr[i2] += (dx / dist) * bhPull; velArr[i2+1] += (dy / dist) * bhPull;
                }
            }
            posArr[i2] += velArr[i2] * dt; posArr[i2+1] += velArr[i2+1] * dt;
            if(posArr[i2] > 1) posArr[i2] = -1; else if(posArr[i2] < -1) posArr[i2] = 1;
            if(posArr[i2+1] > 1) posArr[i2+1] = -1; else if(posArr[i2+1] < -1) posArr[i2+1] = 1;
        }

        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindBuffer(gl.ARRAY_BUFFER, pBuf);
        gl.bufferData(gl.ARRAY_BUFFER, posArr.subarray(0, count * 2), gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(posLoc);

        gl.bindBuffer(gl.ARRAY_BUFFER, cBuf);
        gl.bufferData(gl.ARRAY_BUFFER, colArr.subarray(0, count * 3), gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(colLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(colLoc);

        gl.bindBuffer(gl.ARRAY_BUFFER, sBuf);
        gl.bufferData(gl.ARRAY_BUFFER, sizeArr.subarray(0, count), gl.STATIC_DRAW);
        gl.vertexAttribPointer(sizeLoc, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(sizeLoc);

        gl.drawArrays(gl.POINTS, 0, count);
    }

    function runCanvas(dt, released) {
        // --- LEGACY MODE UPDATED TO 200,000 MAX ---
        ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
        ctx.fillRect(0, 0, c2dCanvas.width, c2dCanvas.height);
        
        const baseFriction = 0.82 + (driftFactor / 5) * 0.178;
        const friction = Math.pow(baseFriction, dt);
        const compressFriction = Math.pow(0.88, dt);

        const colors = [document.getElementById('c1').value, document.getElementById('c2').value, document.getElementById('c3').value];
        const width = c2dCanvas.width;
        const height = c2dCanvas.height;
        const halfW = width / 2;
        const halfH = height / 2;

        // Constraint updated to 200,000 for legacy stability
        const currentCount = Math.min(count, 200000);

        for (let i = 0; i < currentCount; i++) {
            const i2 = i * 2;
            
            let px = (posArr[i2] + 1) * halfW;
            let py = (1 - (posArr[i2+1] + 1) * 0.5) * height;

            let vx = velArr[i2] * halfW;
            let vy = -velArr[i2+1] * halfH;

            let dx = mouse.x - px;
            let dy = mouse.y - py;
            let dist = Math.sqrt(dx*dx + dy*dy) || 1;

            if (mouse.isDown) {
                const sx = -dy / dist;
                const sy = dx / dist;
                vx += (dx * speedArr[i] + sx * swirlForce) * dt;
                vy += (dy * speedArr[i] + sy * swirlForce) * dt;
                vx *= compressFriction;
                vy *= compressFriction;
            } 
            else if (released) {
                const force = (1 / dist) * explosionStrength * (Math.random() * 2 + 0.5);
                vx = (-dx / dist) * force;
                vy = (-dy / dist) * force;
            } 
            else {
                vx *= friction;
                vy *= friction;
                if (Math.random() < 0.1) {
                    vx += (Math.random() - 0.5) * 0.2 * dt;
                    vy += (Math.random() - 0.5) * 0.2 * dt;
                }
                if(blackHoleActive) {
                    vx += (dx/dist) * 0.5 * dt; vy += (dy/dist) * 0.5 * dt;
                }
            }

            px += vx * dt;
            py += vy * dt;

            if(px < 0) px = width; else if(px > width) px = 0;
            if(py < 0) py = height; else if(py > height) py = 0;

            posArr[i2] = (px / halfW) - 1;
            posArr[i2+1] = ((height - py) / halfH) - 1;
            velArr[i2] = vx / halfW;
            velArr[i2+1] = -vy / halfH;

            // Draw with cached colors for speed
            ctx.fillStyle = colors[i % 3];
            ctx.fillRect(px, py, sizeArr[i], sizeArr[i]);
        }
    }

    resize();
    requestAnimationFrame(animate);
</script>
</body>
</html>
    
  </body>
  
</html>
